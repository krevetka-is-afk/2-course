.data
buffer_min: .space 2            # Буфер для минимального символа + конец строки
buffer_max: .space 2            # Буфер для максимального символа + конец строки

.text
.globl process_min_max

process_min_max:
    # Входные параметры:
    # s5 - адрес буфера строки
    #
    # Выходные параметры:
    # s10 - адрес буфера минимального символа
    # s11 - адрес буфера максимального символа

    mv t5, s5              # Сохраняем начальный адрес строки
    li t1, 255             # Инициализируем минимальное значение (максимально возможное для ASCII)
    li t2, 0               # Инициализируем максимальное значение (минимально возможное для ASCII)

find_loop:
    lb t0, 0(t5)           # Загружаем текущий символ
    beqz t0, end_p_m_m     # Если символ равен 0 (конец строки), завершаем цикл

    # Игнорируем пробелы и невидимые символы
    li t3, 32              # Код пробела
    blt t0, t3, find_next  # Если символ < пробела, пропускаем его

    blt t0, t1, update_min # Если текущий символ меньше минимального
    bgt t0, t2, update_max # Если текущий символ больше максимального
    j find_next            # Переход к следующему символу

update_min:
    mv t1, t0              # Обновляем минимальный символ
    j find_next

update_max:
    mv t2, t0              # Обновляем максимальный символ
    j find_next

find_next:
    addi t5, t5, 1         # Переход к следующему символу
    j find_loop            # Повторяем цикл

end_p_m_m:
    la s10, buffer_min     # Адрес буфера для минимального символа
    la s11, buffer_max     # Адрес буфера для максимального символа

    # Записываем минимальный символ в буфер
    sb t1, 0(s10)          # Помещаем минимальный символ
    sb zero, 1(s10)        # Добавляем нулевой символ для конца строки

    # Записываем максимальный символ в буфер
    sb t2, 0(s11)          # Помещаем максимальный символ
    sb zero, 1(s11)        # Добавляем нулевой символ для конца строки

    ret                    # Возвращаемся